# 2. Redis 概述

### 1. Redis 是什么?

Redis是一个开源的 key-valuev 存储系统。支持存储的 value 类型包括 string，list(链表)，set，zset(有序集合)，hash。这些数据类型都支持 push/pop，add/remove 等操作，且这些操作都是原子性的。在此基础上，Redis支持各种不同方式的排序。为了保证效率，数据都是缓存在内存中。与 MemcacheDB 的区别就是 Redis 会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。



**原子性**

原子性是指**一个操作是不可中断的，要么全部执行成功要么全部执行失败，有着“同生共死”的感觉**。即使在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程所干扰。







### 2. Redis 的应用场景

![image.png](https://cdn.nlark.com/yuque/0/2019/png/446852/1576401921722-9eee97b4-9add-4e9b-986d-05d97bba4fb2.png)![image.png](../../imgs/1576401951701-df369f0b-1e23-4637-971c-71078d0ad5e9.png)







### 3. Redis 的使用

**服务器启动**

将 redis.conf 配置文件拷贝到其他目录，例如根目录下的 opt 目录下的 myRedus 目录下。

修改 redis.conf文件中的一项配置 daemonize 将no 改为yes，代表后台启动。

执行配置文件进行启动 执行 redis-server /myredis/redis.conf



**客户端启动** 

1. 使用redis-cli 命令访问启动好的Redis
2. 如果有多个Redis同时启动，则需指定端口号访问  redis-cli -p 端口号
3. 测试验证,通过 ping 命令 查看是否 返回 PONG



**关系 Redis 服务**

如果还没有l通过客户端访问，可直接 redis-cli shutdown

如果已经进入客户端,直接 shutdown/exit 即可。







### 4. Redis 默认 16 个库

Redis 默认创建 16 个库，每个库对应一个下标，从 0 开始。通过客户端连接后默认进入到 0 号库，推荐只使用 0 号库，使用命令 select 库的下标，可以切换数据库。例如：select 8







### 5. Redis 的单线程+多路 IO 复用技术

1. 多路复用是指使用一个线程来检查多个文件描述符（Socket）的就绪状态，比如调用 select 和 poll 函数，传入多个文件描述符，如果有一个文件描述符就绪，则返回，否则阻塞直到超时。得到就绪状态后进行真正的操作可以在同一个线程里执行，也可以启动线程执行（比如使用线程池）。 
2. Memcached 是多线程 + 锁；Redis 是单线程 + 多路 IO 复用。



当现在有很多请求同时访问redis，可以把这些请求全部加一个监视的效果，我们可以监视这个请求是否准备完毕，如果准备完毕，直接让redis进行处理。所以在单线程+多路IO复用里，你的 redis 不会停止，没有阻塞状态，它将一直对请求处理，因为它所处理的请求全都是准备完毕可以直接处理的。



![image.png](../../imgs/1576402626321-98e33dba-c9f4-4574-a9bd-8df09ffa2d92.png)



**什么是多路 IO 复用？**

多路 I/O 复用模型是利用select、poll、epoll可以同时监察多个流的 I/O 事件的能力，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有I/O事件时，就从阻塞态中唤醒，于是程序就会轮询一遍所有的流（epoll是只轮询那些真正发出了事件的流），并且只依次顺序的处理就绪的流，这种做法就避免了大量的无用操作。这里“多路”指的是多个网络连接，“复用”指的是复用同一个线程。采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络IO的时间消耗），且Redis在内存中操作数据的速度非常快（内存内的操作不会成为这里的性能瓶颈），主要以上两点造就了Redis具有很高的吞吐量。



**为什么要采用多路复用**

Redis 是跑在单线程中的，所有的操作都是按照顺序线性执行的，但是由于读写操作等待用户输入或输出都是阻塞的，所以 I/O 操作在一般情况下往往不能直接返回，这会导致某一文件的 I/O 阻塞导致整个进程无法对其它客户提供服务，而 I/O 多路复用就是为了解决这个问题而出现的。